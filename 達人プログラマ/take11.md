# 偶発的プログラミング
我々は慎重なプログラミングを選ぶべきである。
## 偶発的プログラミングの方法。
プログラマーがコードを記述し、テストを行い、バグがないことを確認したうえで次に進んだ。それを繰り返すうちにバグが大量に発生し、ソフトウェアが修復不可能となった。
###  実装の事故
ある機能をその作者が想定していないデータを用いて呼び出した場合。
この場合、
- 動いているように見えるだけで実際は動いてない
といったことなる。また
- 偶発的な条件かもしれない。異なった状況下(異なった画面解像度やCPUコア数)では動いてくれないかもしれない。
- 次のリリースでドキュメント化されていない動作が変更になるかもしれない
- 不必要な呼び出しが余分にあるとコードが遅くなる
- 余計な呼び出しで新たなバグを混入させる危険性も

自らが他人の使うコードを開発しているのであれば正しいモジュール化の原則にのっとり、かつドキュメント化されたインタフェースの背後に実装を隠すということを適用するべきである。

また何らかの機能を呼び出すのであればドキュメント化されているふるまいを前提としよう。

### 十分近いは外れに同じ。
あるプロジェクトで数値が少し違うから即席で1増やす、減らすという処理をしようという実装が常態化していた。しかしその実装には根本の問題があり、その対処ができずにそのプロジェクトは破棄された。
### 幻のパターン
人間、それが偶然でも謎のパターンを見出そうとする。
パターンをもし見つけたと感じたとき、その**具体的な証明**が必要なのである。
### コンテキストの事故
自らが開発中のものに対して考えている前提は本当に正しいのであろうか。(書き込み権限やGUI前提なのかといったもの)。

またほかのところからコードをコピペするとき、そのコードは同じ前提にあるものと保証はできるのか。

ぴったりと適合する答えがあったとしてもそれが本当の答えとは限らない。

**<font color = red>偶発的プログラミングは行わない</font>**

### 暗黙の仮定
人間ドキュメント化されていない仮定に基づいてコーディングをしがちである。しかしこういった仮定は開発者間で矛盾することも多い。

事実に基づいていない証明されない仮定はあらゆるプロジェクトで有害なものとなる。

## <font color = skyblue> 慎重なプログラミングの方法</font>
- 常に自分が何をやってるのか意識する
- 人にコードの説明をできるようにする
- なじみのない技法や完全に理解していないアプリケーションを使う際、うまく動作している理由を説明できないのであれば利用しない。
- まず**プランから進めるよう**にする
- 確実に信頼のおける物事のみを前提とする。
- 仮定を**ドキュメント化**する
- 自分の仮定が正しいかどうかのテストを行う(表明などを用いる)
- 作業に優先順位をつける
- 既存のコードによって将来のコードに影響を及ぼさないようにする

きちんと動いているように見えるが動作している理由がわからない場合、単なる偶然なのかを見極めるべきである。

# アルゴリズムのスピード
優れたプログラマーはアルゴリズムが消費する時間やメモリといったリソースの見積もりを毎日行っている。
## アルゴリズムの見積もり
ほとんどのアルゴリズムは可変入力を伴うアルゴリズムとなる。

通常、入力サイズの大きさに比例して実行時間やメモリは大きくなる。そのほとんどは非線形。

ループや再起呼び出しを扱うとき我々は無意識のうちにリソースを気にするが明確なプロセスにはなっていないことが多い。

しかし時にはこれについて詳細な分析が必要になることがある。
## O記法
最悪計算時間のこと。最悪の場合どのくらい時間がかかりますよ。というもの。

であるがO記法が実際の時間を表しているわけではなく、単に**入力が変わった時の変化**を表している。

またO記法はメモリ消費のモデル化など時間の見積もり以外にも用いることができる。

## 見積もりについての一般心得
### 単純なループ
- 1-nまでの繰り返し
- 大体は$O(n)$。つまり線形増加
- 順次検索、配列中の最大値取得など
### ネストしたループ
- 二つのループの上限値をm,nとすると大体$O(m\times n)$
- バブルソートなど
- $O(n^{2})$に近いものになる
### 2分割
ループの中で対象データをに分割する処理
- 大体$O(\log n)$
- バイナリサーチなど
### 分割統治法
入力を分割してそれら二つを独立のものとして操作した後結果を結余郷するアルゴリズム
- 大体$O(n \log n)$
- クイックソートなど
### 組み合わせ
組み合わせを探査するアルゴリズム
- 大体手に負えないものになる
- 巡回セールスマン問題、ナップサック問題など
- こういう場合は時間低減のために発見的手法を用いることが多い。
### 現実的なアルゴリズムのスピード
- ソートは大体提供されているものを使う
- だがO記法を頭の中で考え、ループが$O(n)$になることやネストが$O(n^{2})$になることは考慮するべき
- それでコードの実行に必要なリソースが大体わかるはず

**<font color = skyblue>アルゴリズムのオーダを見積もる</font>**

- 潜在的な問題に取り組むアプローチを考える
  - $O(n^{2})$のソートを分割統治法で$O(n \log n)$にできるかもしれない
- 使用リソースがわからなければ
    1. 入力件数や実行時間に影響を与えそうなものを実行
    2. 影響を実際に確認(グラフにプロットするなど)
- コード自身が何を行っているか考える
  - $O(n^{2})$のソートが$O(n \log n)$よりも効率的かもしれない
  - 少ない入力件数では線形に見えても増やしたら一気に膨れ上がるやもしれない。
- 理論面と現実面で考えることが重要

**<font color = skyblue>見積もりの検証を行う</font>**

### 最善は最善ではない
- 常に最速のアルゴリズムが最適かといわれるとそうではない。
- 単純なソートのほうがデバッグ時間を短縮できるかもしれない

開発者はどのようにアルゴリズムを設計、分析するかの感覚を必ず身に着ける必要がある。(SW11とかはいいかも)


