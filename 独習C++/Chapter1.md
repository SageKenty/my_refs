# 1.2
## 1.2.2　const修飾子
定数を定義する宣言。const修飾子で定義された変数は**const変数**といい、ほかの値を代入できない。
```cpp
// const <variable-type> <variable-name> = <value>
const int CONSTANT = 8
```
初期化を欠くとエラーになる
# 1.3
## 1.3.2　ビット演算子とシフト演算子
| 演算子 | 使用例 | 意味          |
| ------ | ------ | ------------- |
| ^      | a^b    | aとbのxor演算 |
| ~      | ~a     | aのnot演算    |
## 1.3.3 sizeof演算子
その要素のビット数を取得できる。

- **std::size_t型**を返す。

std::size_t型はそのほかにも何かしらのサイズを表すときによく使われる。

- **char型は1バイト**、int型は4バイトを大体返す。

# 1.4 条件分岐
条件分岐は
- if
- else if
- switch文
- 三項条件演算子
などがある
## 1.4.4 goto文
``goto``のところに行き着いたときに強制的にラベルのところに移動する
```cpp
label:

goto label;
```
### 使用例
エラーが起こったかどうかのbool型の変数を**フラグ**(flag)としてとっておき、条件分岐で処理を行いエラーが起これば別の処理を行う手法である
```cpp
bool some_function()
{
    /*処理A*/
    bool error = /*処理Aの結果*/
    if(error)
    {
        goto fail;
    }
    /*処理B*/
    bool error = /*処理Bの結果*/
    if(error)
    {
        goto fail;
    }
    /*処理C*/
    bool error = /*処理Cの結果*/
    if(error)
    {
        goto fail;
    }

    return true; //処理成功

    fail: //ラベル
    /*エラー処理*/
    return false; //失敗を表すfalse
}
```
# 1.5 組み込み型とポインタ(参照:独習C)
## 1.5.1 組み込み型
| 型           | 用途                                               | 値の範囲                                |
| ------------ | -------------------------------------------------- | --------------------------------------- |
| unsigned int | 符号なし整数                                       | 0以上の整数                             |
| short        | 符号付き整数                                       | int型と同じか<br>それより狭い範囲の整数 |
| long         | 符号付き整数                                       | intより広い範囲の整数                   |
| double       | 符号付き実数                                       | floatより広い範囲の実数                 |
| void         | 整数を定義できない。<br>返り値のない関数の定義など | なし                                    |
---
### 浮動小数点数
```cpp
//最後にfつけるとfloat型になる
float pi = 3.1415926f
```
## 1.5.2 リテラル
プログラム中の文字列や数値などのデータを**リテラル**という。
またデータを目的の型にするために**プレフィックス**(prefix)や**サフィックス**(suffix)がつくことがある。

| リテラル例 | 型              | 意味                 |
| ---------- | --------------- | -------------------- |
| `0`        | `int`           | 整数リテラル         |
| `1u`       | `unsigned int`  | 整数リテラル         |
| `2l`       | `long`          | 整数リテラル         |
| `3ul`      | `unsigned long` | 整数リテラル         |
| `6.7f`     | `float`         | 浮動小数点数リテラル |
| `8.9`      | `double`        | 浮動小数点数リテラル |
| `'0'`      | `char`          | 文字リテラル         |
| `"11"`     | `char[]`        | 文字列リテラル       |

以上などがある。

## 1.5.3 ポインタ
- 変数アドレスを取得するには変数の前に**アドレス演算子**`&`をつける
- ポインタは型を持つので別の型のポインタを入れることはできない
- ポインタを利用して変数を操作するには**間接参照演算子**`*`をつける
- 関数の引数としてポインタを渡すことを**ポインタ渡し**という。
- ポインタ宣言は変数それぞれの前に`*`をつける必要がある
```cpp
int *p,*s
```
### 関数の呼び出しとポインタの例
```cpp
#include <iostream>

void nochange(int i)
{
    // 仮引数を変更するが、呼び出した変数自体は変更されない
    i = 42;
}

void set42(int* pi) // int型へのポインターを引数として受け取る
{
    // 引数で渡されたアドレスが指し示す変数に42を代入する
    *pi = 42;
}

int main()
{
    int i = 0; // iはこの時点では0

    nochange(i); // 変数iが持っている値だけを渡す

    // 変数i自体は変更されない
    std::cout << i << std::endl;

    set42(&i); // 変数iへのアドレスを渡している

    // set42がアドレスを使って変数iを変更しているので、iの値は42になっている
    std::cout << i << std::endl;
}

```

## 1.5.4　const修飾子とポインタ
`const`変数を表すポインター
```c
//const <typename> <variablename>
const int* const_intptr;
```
-`const`ポインタは**指し示す先の変数**が変更不可能であることを示す。
- `const`ポインタ自体は代入による変更可能
- 普通の変数へのアドレスは`const`ポインタに代入可能
- 逆に普通のポインタへconstポインタは**代入不可能**
### ポインタ変数自体をconst(変更不可能)にしたい場合
```cpp
//typename* const valiable-name = initial-address
int* const int_constptr= &a
```
const修飾子が`*`の前か後かでニュアンスが変わる。
## 1.5.5 ヌルポインタ
どの変数も指し示さないアドレス
- ポインタ型変数に`0`を代入する
- ヌルポインタリテラル`nullptr`の使用

のいずれかで定義できる。
### 無効なポインタ
以下のように`nullptr`を参照しようとすると、
```c
int main()
{
    int* ptr = nullptr;

    *ptr = 42; // ヌル参照

    std::cout << "ヌル参照のあと" << std::endl;
}

```
`segmentation fault`エラーが起こり、クラッシュする。

なのでポインタが有効なアドレスを持っていると確信できるとき以外はヌルポインタかどうか確認するのが最善。
```c
int main()
{
    int* ptr = nullptr;

    if (ptr == nullptr)
    {
        std::cout << "ptrはヌルポインターです" << std::endl;
    }
    else
    {
        *ptr = 42;
    }
}
```
## 1.5.6 型変換
### 暗黙の型変換
一部の組み込み型は自動的に型変換がされることがある。これを**暗黒の型変換**という。
- 浮動小数点数型`double,float`を`int`型の変数に代入することはできるが小数点以下が切り捨てになる
- 逆の場合は小数点以下0で代入される
- 狭い範囲の型からより広い範囲を扱う変数への代入は問題ない
### キャスト演算子
```cpp
//static_const<target-type>(expression)
static_const<int>(valiable)
```

自分で意図的に型変換を行う際に使用する演算子。
以下のプログラムのを実行したとき、char型の変数を`std::cout`がそのまま文字として扱い、`c`と表示される。

なので**いったん整数型に変換して表示**をする必要がある。

例
```cpp
int main()
{
    char c = 99;

    std::cout << c << std::endl; 
    // キャスト演算子を使ってint型に変換して表示
    std::cout << static_cast<int>(c) << std::endl;
}
```
結果
```
c
99
```
# 1.6 配列と文字列
## 1.6.3　文字列
文字の配列
- 文字を変数に格納したとき、「char型の変数一つ」か「char」型の配列かの違いとなる。

### プログラム例
```cpp
#include <iostream>
int main()
{
    char hello[] = "Hello"; // 文字列リテラルで初期化

    char array[6] = { 'a', 'r', 'r' }; // 文字リテラルの配列として初期化
    array[3] = 'a'; // 1文字ずつ代入してもよい
    array[4] = 'y';
    array[5] = '\0'; // ヌル文字

    std::cout << hello << ", " << array << std::endl;
}

```
- 以上のプログラムでは、arrayは5文字にもかかわらずサイズを6確保して最後に**ヌル文字(`\0`)** を代入している。
- 文字列は**必ず最後にヌル文字を入れる決まりになっている。** このような文字列を**ヌル終端文字列**という。
- 配列のスペースが余った分は自動的にヌル文字で保管される。
- 配列のサイズを自分で決める際には必ず**文字数+1**は確保する。

## 1.6.4 std::string
C++における文字列を簡単に扱えるようにした型。配列との違いは以下の点にある。
- `std::string`で初期化可能
- `std::string`を代入可能(長さが異なってもよい)
- 文字列リテラルを代入できる(長さが異なってもよい)

代入する文字列の長さに応じて自動で長さが変わる代物。

# 1.7 繰り返し
## while文
### break文とcontinue文
- **`break`:** その場でループ処理を中断し、ループの次にある処理に移る
- **`continue`:** **ループ一回分の残りの処理をスキップ**し、ループの先頭の**条件式の処理**へ進むことができる

`break`文や`continue`文を使うと配列を先頭から順番に処理する際、エラーとなる値があればそこで中断するかそこだけをスキップして次に進むといったことができる。
## for文
### 範囲for文
- `for`文を使い配列を先頭から順番に処理するようなループの使い方を**走査**という。
- 走査専用の`for`文を**範囲for文**という。

構文:
```cpp
/*
for(type variable : range)
{
    statements
}
*/
//例:
int main(){
    int value[] = { -20, 10, 5, -40, 0, 10, -30 };
    for(int elem : value)
    {
        std::cout << elem << std::endl;
    }
}
```
以上のプログラムは単に配列の要素を表示するプログラム。

## do文
一度プログラムを実行してからループの継続を判断したいといった場合に使用する構文

構文
```cpp
do
{
    //statement
}
while (condition);
```
- 他の構文と違い、while文の後にセミコロンがいる。

### 使用例
```c
do
    {
        if (value[i] < 0)
        {
            std::cout << "continue" << std::endl;
            ++i; // 重要
            continue; // 条件文に飛ぶ
        }

        if (value[i] == 0)
        {
            std::cout << "break" << std::endl;
            break; // ループを終了する
        }

        std::cout << "elem = " << value[i] << std::endl;
        ++i; // 配列のインデックスを1つ進める
    } while (i < 7);

```
以上の構文では
1. value値を基にした動作の診断
2. 継続するかの判断(条件検査)

の順番で繰り返しを行っている。